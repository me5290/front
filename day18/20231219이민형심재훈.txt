자료를 메모리에 저장하기 위해 사용함
1. 변수
    변수 - 데이터가 언제든지 바뀔수 있는 수
    변수 선언 - var,let

    let 변수명 = 값

    let x = 10


2. 상수
    상수 - 데이터가 고정된 수
    상수 선언 - const

    const 상수명 = 값

    const y = 10
    
전역변수/지역변수
전역변수의 경우 블록 외부에서 선언되었고 여러 함수들이 참조 가능함.
지역변수의 경우 블록 내부에서 선언되었고 자신의 자식블록이 아닌 다른 외부함수 등에서 참조가 불가능함
따라서 다른 함수에서 지역변수를 참조하고 싶다면 매개변수를 이용하여 값을 받아와야함
----------------------------------------------
자료형
3. 숫자
숫자 - 정수,실수 등 모든 숫자
다른 타입의 자료형을 숫자자료형로 바꿔주는 함수는 Number
typeof:number
이렇게 바꾼 자료형을 isNAN함수를 이용해 숫자자료형인지 아닌지 확인 가능
예시:273,51,1004,16,-40


연산
	+더하기
	-빼기
	*곱하기
	/나누기 -> 정수의 나눈 몫을 구하고 싶다면 자료형에 parseInt를 선언해 미리 정수로 바꾸어 줘야함 
	%나머지
	전위증감,후위증감
	을 Number끼리 했을시 값의 자료형이 Number로 나옴


4. 문자열
    문자열 - 기본적으로 '' 또는 "" 안에 들어간 데이터

    다른 타입의 자료형을 문자열자료형로 바꿔주는 함수는 String

    "안녕하세요","273","string"

연산
	+문자열 붙이기 연산



5. 불
불 - true/false로 나뉜다
다른 타입의 자료형을 불자료형로 바꿔주는 함수는 Boolean
true,false
불은 true|false로 나누어지며 undefinded,빈문자열,0,null등을 Boolean 했을경우 값이 false가 나온다
연산
비교연산자
>초과 <미만
>=이상 <=이하
==같다(자료형무시) ===같다(자료형포함)
!=같지않다(자료형무시) !==같지않다(자료형무시)
관계 연산자
&& (and)
|| (or)
! (not)	and		or 		not
	b 1 0		1 0		
a
 1	  1  0		1  1		0
 0	  0  0		1  0		1
(1=true,0=false)

의 경우 결과값이 불 자료형으로 나오게 된다
불의 경우 주로 반복문의 조건으로 많이 들어가게 되는데
비교연산자를 통해 나온 결과값이 불 자료형이기 때문에 예를들어
while(1>2)의 경우 괄호안의 값이 false가 나오기 때문에 반복문을 실행하지 않는다.

6. 배열
배열 - 여러 요소를 한곳에 저장할수 있는 곳
[]안에 ,로 요소를 구분한다.
변수or상수 배열명 = [];
const 배열 = ["안녕하세요",273,true,function(){},{객체},[배열]];
배열의 인덱스 번호는 0부터 시작 
주로 요소들의 자료형이 같을경우 배열을 사용하는편


7. 함수
함수 - 코드들의 집합
함수호출 - 함수명(매개변수);    
function 함수명(매개변수){
        실행코드;
        리턴;
}

    function 함수명(x){
        x + x;
        return;
}
함수명(10);

return을 통해 함수를 탈출함

함수 시간복잡도:
주로 빅오 표기법을 이용(빅세타,빅오메가)
함수 내부의 반복정도(반복문,재귀)에 영향을 받으며
O(1)<O(n)<O(nlogn)<O(n^2)<O(2^n)<O(n!)
순으로 속도가 커진다
O(n^2)이상으로 가면 시간복잡도가 너무 커져서 사용 X

8. 객체
    객체 - 프로퍼티의 집합
    프로퍼티: 키-값쌍
    객체 입력 형태 -{key1 : '값1', key2 : '값2', key3 : '값3'}
    객체 호출 -  객체명.key1
                객체명['key1'] 

    const 객체명 = {
        문자열 : "문자",
        숫자 : 273,
        불 : false,
        배열 : [1,2,3],
        함수 : function(){},
        객체 : {객체2 : 값}
}    
주로 key값에는 문자열이 들어가고
value로는 모든 자료형(숫자,문자,불,배열,함수,객체)전부 가능함.
t.key1 -> value1
t[key1] -> value1
새로운 key값 입력
t.key4 = value4
삭제
delete t.key4


상속....되나?
-> prototype을 이용해 상속받는다고함(?)
배열 내 자신의 값을 호출하려면 this 키워드
배열 내 부모의 값을 호출하려면 super키워드 이용
->메소드 오버라이딩 일어남
메소드 오버라이딩:부모에게서 상속받은 메소드를 재정의 가능
메소드 오버로딩(같은 메소드를 선언하나 매개변수의 갯수를 달리하여 같은 메소드를 중복으로 선언하는 방식)은 직접적으로 지원 X



